[[LanguageReference]]
== Language Reference

=== Basic
To illustrate the use of K3, in the following sections, we will extend a base 
java structure. so letâ€™s consider the following set of classes of a small ecore 
representing a Blog.

.Metamodel used as base for the examples)
image::images/blog-base-diagram.png[]

==== Creating an aspect on a class

Defining an aspect on a class is done by adding the annotation __**Aspect**__ 
on the class corresponding to the aspect. The annotation parameter **className** will indicates which is the base 
class that will be augmented.


[source,k3]
----
package blogsite.aspects

import fr.inria.diverse.k3.al.annotationprocessor.Aspect <1>

import blogsite.Blog

@Aspect(className=Blog) <2>
class BlogAspect {
    def void display (){
         prinln("I am BlogAspect")
    }
}
----

<1> Import the annotation processor for Aspect
<2> Add an aspect on top of class Blog

In an aspect you can use the attributes and operations of both the augmented 
class and the aspect itself.

In aspects, **the keyword** "__**this**__" 
**must not be used**. Use the 
keyword "**_self**" instead.

[source,k3]
----
@Aspect(className=Blog)
class BlogAspect {
    int blogVersion = 1 <1>

    def void changeTitle (String  newTitle, int newVersion){
         // The keyword _self must be used to refer to attributes and operations of the class and aspect.
         _self.blogVersion = newVersion <2>
         _self.title =  newTitle <3>
    }
}
----

<1> this attribute exists only in the aspect
<2> in aspect, attribute defined on aspect is accessed via **_self**
<3> in aspect, attribute defined on the base class is accessed via **_self**

[WARNING]
====
Despite it should be legal, due to a bug in xtend, we **do not** recommand the following syntax:

----
@Aspect(className=typeof(OtherClass))
----

It may raise strange scope issue, especially in case of aspects 
defined in several packages.
====

==== Using aspect from another k3/xTend program

To use the aspect, you need to import the correct classes and indicates to 
xTend thant some additionnal features can come from the aspect.

This is done using the special import **import 
static extension** which enable the use of the additions declared 
in the aspect.

[source,k3]
----
package blogsite.demo

import blogsite.Blog
import blogsite.aspects.BlogAspect

import static extension blogsite.aspects.BlogAspect.* <1>

class Main {
    def static void main(){
      val Blog b1 = new Blog
      b1.display() <2>
    }
}
----

<1> This __import static extension 
<myPkg.AspectName>.*__ allows to make visible the attributes and 
operations defined on BlogAspect.
<2> method display() is visible thanks to the __import 
static extension BlogAspect.*__

[[Disambiguation]]
===== Disambiguation

If several operations or attributes have similar names, xTend may not find the 
expected feature. In that case you need to disambiguate the call by accessing 
the underlying helper class.

[NOTE]
====
To have more details about the precise mechanism of this helper class 
please refer to the chapter at the end of this document.
====

[source,k3]
----
@Aspect(className=Blog)
class BlogAspect2 {
    int title = 1 <1>
}
----

[source,k3]
----
import static extension blogsite.aspects.BlogAspect2.*

class Main {
    def static void main(){
      val Blog b1 = new Blog
      println( b1.title) <2>
      println( BlogAspect2.title(b1) <3>
    }
}
----

<1> Might be ambiguous because it reuse the name of an attribute on the base class
<2> returns the attribute ``title`` of the base object 
b1.
<3> return the attribute ``title`` of the companion object 
for the aspect BlogAspect2.



[TIP]
====
Be careful when cleaning unused imports while your programs isn't complete (for example using **ctrl+shift+o**) because it will also removed unused static extension and will disable the code completion (**ctrl+space**) for the features of these aspects.
====

==== Aspect inheritance (simple inheritance)

An Aspect class can inherit fields and methods from another class. The simple inheritance is acheived using the **__extends__** keyword from Xtend.

[IMPORTANT]
====
However, as for Java, an aspect can directly inherit from only one aspect ! For 
multiple inheritance, please refer to the advanced section.
====

[source,k3]
----
package blogsite.aspects

import fr.inria.diverse.k3.al.annotationprocessor.Aspect
import fr.inria.diverse.k3.al.annotationprocessor.OverrideAspectMethod

import blogsite.HasAuthor
import blogsite.Post

import static extension blogsite.HasAuthor.*
import static extension blogsite.PostAspect.*

@Aspect(className=HasAuthor)
class HasAuthorAspect {

    def String display (){
        returns _self.author
    }
}

@Aspect(className=Post)
class PostAspect extends HasAuthorAspect{ <1>

    @OverrideAspectMethod <2>
    def String display (){
        returns _self.title + " by " + _self.author
    }
}
----

<1> PostAspect inherits from HasAuthorAspect
<2> the **__OverrideAspectMethod__** 
annotionation is required to indicates that the method already exists in the 
parent aspect class and must be overriden.


==== Calling a super operation
A call to a super operation can be done by writing **super_** followed by the name of the 
operation. Do not forget to use **_self** 
to handle elements of the class or aspect.

The previous example could have been written like this:

[source,k3]
----
package blogsite.aspects

import fr.inria.diverse.k3.al.annotationprocessor.Aspect
import fr.inria.diverse.k3.al.annotationprocessor.OverrideAspectMethod

import blogsite.HasAuthor
import blogsite.Post

import static extension blogsite.HasAuthor.*
import static extension blogsite.PostAspect.*

@Aspect(className=Post)
class PostAspect extends HasAuthorAspect{

    @OverrideAspectMethod
    def String display (){
        returns _self.title + " by " + _self.super_display() <1>
    }
}
----
<1> call the parent display() method


=== Advanced

==== Extending an aspect (multi inheritance)
Even if Java allows only one inheritance via _extends_.
When using EMF, it is legal to inherit from several class. The underlying framework will take care to implement a pattern using Interfaces.

Our aspects must also be able to deal  with that situation.

The **@Aspect** annotation can then take a **with** attribute to indicate this inheritance.

If the following ecore model and its java implementation, there is a multi-inheritance from Child class to 3 ParentX classes.

.Metamodel used as base for the multi inheritance example
image::images/multi-inheritance-base-diagram.png[]

then, in order to correctly reflect these inheritances in the aspects, we will define the following.

[source,k3]
----
// [..]

import static extension multiparents.Parent1.*
import static extension multiparents.Parent2.*
import static extension multiparents.Parent3.*
import static extension multiparents.Child.*

@Aspect(className=Parent1) <1>
class Parent1Aspect {
   def void someParent1Method(){
      // [..]
   }
}
@Aspect(className=Parent2) 
class Parent2Aspect {
   def void someParent2Method(){
      // [..]
   }
}
@Aspect(className=Parent3) 
class Parent3Aspect {
   def void someParent3Method(){
      // [..]
   }
}

@Aspect(className=Child, with=#[ParentAspect2, ParentAspect3] ) <2>
class ChildAspect extends Parent1Aspect{ <3>
   def void someMethod(){
      _self.someParent1Method()
      _self.someParent2Method()
      _self.someParent3Method()
   }
}

----
<1> each parent defines its own aspects.
<2> secondary aspect inheritances are added thanks to the **with** attribute.
<3> primary aspect inheritance is declared using the **extends** keyword like a single inheritance.

.Multi inheritance example with aspects
image::images/multi-inheritance-base_and_aspects-diagram.png[]

[TIP]
====
The syntax `with=#[ParentAspect2, ParentAspect3]`  indicates that we create a list with 2 additional parents (in addition to the primary one that has been defined using the **extends** keyword). If there is only one additional parent, then the following syntax will also work : `with=ParentAspect2`
====

[IMPORTANT]
====
When an ecore model defines an inheritance structure, the best practice is to fully reflect the structure in the aspects. Othewise, the dynamic dispatch may lead to non-intuitive behaviors.
====



=== Replacing a method of the base class

Sometimes the base class already declares some methods but you need to redefine it in your aspects.
For this, K3 uses the **@ReplaceAspectMethod** annotation to provide a replacement method to be used instead of a method 
defined in the base class.

A typical use case is a method declared in the ecore metamodel like in the following example.
In this example, the *System* class defines a *run* method. However, by default in ecore, it has no implementation. (It throws a ``UnsupportedOperationException``)

.Base class with methods
image::images/replaceaspectmethod_mm.png[]


Then, if in your code you wish to refine it in an aspect, you probably expect to be able to call it like this:
.Base class method call problem
image::images/replaceaspectmethod_call_problem.png[]

Unfortunately, even with the _import static extension_ declaration, using this syntax (``sm.run``), java/xtend will still 
call the method declared on the base class.

To have the desired behavior, two solutions: 

- use a non ambiguous syntax for the call: ``FSMAspect.run(sm)`` (see <<Disambiguation>>); but this must be done on every call to the run method.
- use the **@ReplaceAspectMethod** annotation on the _FSMAspect.run() method_. This makes sure that the replacement method will be called everywhere instead
of the method on the base class. 

[NOTE]
====
Internally, this annotation indicates to create and use an aspectJ pointcut that replaces the calls to the base class method and replace it by a call to the corresponding method in the K3 aspect class. 
====
  




